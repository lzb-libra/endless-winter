<template>
  <div class="main">
    <div class="left">
      <canvas ref="seatCanvas" :width="canvasWidth" :height="canvasHeight"></canvas>
    </div>
    <div class="right">
      <n-upload :default-upload="false" :multiple="true" :show-retry-button="true" :show-file-list="false"
        v-model:file-list="fileList" @change="handleUploadChange">
        <n-button>‰∏ä‰º†Êñá‰ª∂</n-button>
      </n-upload>
      <n-button @click="showModal = !showModal">Áé©ÂÆ∂Êï∞ÊçÆ</n-button>
    </div>
  </div>
  <n-modal v-model:show="showModal">
    <n-card style="width: 80vw; height: 83vh;" title="Áé©ÂÆ∂Êï∞ÊçÆ" :bordered="false" size="huge" role="dialog"
      aria-modal="true">
      <div v-if="fileList.length > 0" style="display: flex; align-items: center; margin-bottom: 10px;">
        <n-progress style="flex: 1;" type="line" :percentage="percentage" indicator-placement="inside" processing />
        <span style="padding-left: 10px;">{{ count }} / {{ fileList.length }}</span>
      </div>
      <n-data-table :style="{ height: `${height}px` }" :columns="columns" :data="tableData" :pagination="false"
        @update:sorter="handleSorterChange" :key="row => row.key" :bordered="false" flex-height striped />
    </n-card>
  </n-modal>

</template>

<script setup>
import { ref, onMounted, onUnmounted, defineComponent, h } from 'vue';
import { createWorker } from 'tesseract.js';

const columns = [
  {
    title: 'ÂêçÁß∞',
    key: "name",
    render(row) {
      const index = getDataIndex(row.key);
      return h(ShowOrEdit, {
        value: row.name,
        onUpdateValue(v) {
          tableData.value[index].name = v;
        }
      });
    }
  },
  {
    title: 'ÁõæÂÖµÊîªÂáªÂäõ',
    key: "dbgjl",
    sorter: 'default',
    render(row) {
      const index = getDataIndex(row.key);
      return h(ShowOrEdit, {
        value: row.dbgjl,
        onUpdateValue(v) {
          tableData.value[index].dbgjl = v;
        }
      });
    }
  },
  {
    title: 'ÁõæÂÖµÈò≤Âæ°Âäõ',
    key: "dbfyl",
    sorter: 'default',
    render(row) {
      const index = getDataIndex(row.key);
      return h(ShowOrEdit, {
        value: row.dbfyl,
        onUpdateValue(v) {
          tableData.value[index].dbfyl = v;
        }
      });
    }
  },
  {
    title: 'ÁõæÂÖµÁ©øÈÄèÂäõ',
    key: "dbctl",
    sorter: 'default',
    render(row) {
      const index = getDataIndex(row.key);
      return h(ShowOrEdit, {
        value: row.dbctl,
        onUpdateValue(v) {
          tableData.value[index].dbctl = v;
        }
      });
    }
  },
  {
    title: 'ÁõæÂÖµÁîüÂëΩÂäõ',
    key: "dbsml",
    sorter: 'default',
    render(row) {
      const index = getDataIndex(row.key);
      return h(ShowOrEdit, {
        value: row.dbsml,
        onUpdateValue(v) {
          tableData.value[index].dbsml = v;
        }
      });
    }
  },
  {
    title: 'ÁüõÂÖµÊîªÂáªÂäõ',
    key: "mbgjl",
    sorter: 'default',
    render(row) {
      const index = getDataIndex(row.key);
      return h(ShowOrEdit, {
        value: row.mbgjl,
        onUpdateValue(v) {
          tableData.value[index].mbgjl = v;
        }
      });
    }
  },
  {
    title: 'ÁüõÂÖµÈò≤Âæ°Âäõ',
    key: "mbfyl",
    sorter: 'default',
    render(row) {
      const index = getDataIndex(row.key);
      return h(ShowOrEdit, {
        value: row.mbfyl,
        onUpdateValue(v) {
          tableData.value[index].mbfyl = v;
        }
      });
    }
  },
  {
    title: 'ÁüõÂÖµÁ©øÈÄèÂäõ',
    key: "mbctl",
    sorter: 'default',
    render(row) {
      const index = getDataIndex(row.key);
      return h(ShowOrEdit, {
        value: row.mbctl,
        onUpdateValue(v) {
          tableData.value[index].mbctl = v;
        }
      });
    }
  },
  {
    title: 'ÁüõÂÖµÁîüÂëΩÂäõ',
    key: "mbsml",
    sorter: 'default',
    render(row) {
      const index = getDataIndex(row.key);
      return h(ShowOrEdit, {
        value: row.mbsml,
        onUpdateValue(v) {
          tableData.value[index].mbsml = v;
        }
      });
    }
  },
  {
    title: 'Â∞ÑÊâãÊîªÂáªÂäõ',
    key: "ssgjl",
    sorter: 'default',
    render(row) {
      const index = getDataIndex(row.key);
      return h(ShowOrEdit, {
        value: row.ssgjl,
        onUpdateValue(v) {
          tableData.value[index].ssgjl = v;
        }
      });
    }
  },
  {
    title: 'Â∞ÑÊâãÈò≤Âæ°Âäõ',
    key: "ssfyl",
    sorter: 'default',
    render(row) {
      const index = getDataIndex(row.key);
      return h(ShowOrEdit, {
        value: row.ssfyl,
        onUpdateValue(v) {
          tableData.value[index].ssfyl = v;
        }
      });
    }
  },
  {
    title: 'Â∞ÑÊâãÁ©øÈÄèÂäõ',
    key: "ssctl",
    sorter: 'default',
    render(row) {
      const index = getDataIndex(row.key);
      return h(ShowOrEdit, {
        value: row.ssctl,
        onUpdateValue(v) {
          tableData.value[index].ssctl = v;
        }
      });
    }
  },
  {
    title: 'Â∞ÑÊâãÁîüÂëΩÂäõ',
    key: "sssml",
    sorter: 'default',
    render(row) {
      const index = getDataIndex(row.key);
      return h(ShowOrEdit, {
        value: row.sssml,
        onUpdateValue(v) {
          tableData.value[index].sssml = v;
        }
      });
    }
  }
]

const seatKey = new Map([
  ['north', new Map([
    ['0', [5, 1, 9, 25, 45, 61]],
    ['1', [17, 13, 21, 29, 53, 65]],
    ['2', [37, 33, 41, 49, 57, 69]],
  ])],
  ['east', new Map([
    ['0', [6, 2, 10, 26, 46, 62]],
    ['1', [18, 14, 22, 30, 54, 66]],
    ['2', [38, 34, 42, 50, 58, 70]],
  ])],
  ['south', new Map([
    ['0', [7, 3, 11, 27, 47, 63]],
    ['1', [19, 15, 23, 31, 55, 67]],
    ['2', [39, 35, 43, 51, 59, 71]],
  ])],
  ['west', new Map([
    ['0', [8, 4, 12, 28, 48, 64]],
    ['1', [20, 16, 24, 32, 56, 68]],
    ['2', [40, 36, 44, 52, 60, 72]],
  ])],
]);

let seatDatum = [
  { "name": "ÂìÜÂï¶AÊ¢¶", "dbgjl": "802.6", "dbfyl": "803.8", "dbctl": "354.5", "dbsml": 333.5, "mbgjl": 975.9, "mbfyl": 977.1, "mbctl": 345.1, "mbsml": 342.5, "ssgjl": 975, "ssfyl": 983.9, "ssctl": 424.3, "sssml": 415.1 },
  { "name": "È¢ùÈÄÉË∑ëË¥ºÂø´", "dbgjl": 801.4, "dbfyl": 771.2, "dbctl": 276.4, "dbsml": 369.9, "mbgjl": 836.7, "mbfyl": 820.2, "mbctl": 366.1, "mbsml": 256.4, "ssgjl": 925, "ssfyl": 903.1, "ssctl": 409.4, "sssml": 284.6 },
  { "name": "Â∑¥ÊâéÂòøÁöÑ‰∏ÄÂè∑Â∞èÂºü", "dbgjl": 704.5, "dbfyl": 702.6, "dbctl": 236.7, "dbsml": 325.2, "mbgjl": 778, "mbfyl": 763, "mbctl": 311.9, "mbsml": 219.8, "ssgjl": 872.8, "ssfyl": 855.5, "ssctl": 381.9, "sssml": 245.4 },
];

// ÁîªÂ∏ÉÂ§ßÂ∞è
const canvasWidth = 1820;
const canvasHeight = 1070;

let scale = 1.0;          // ÂΩìÂâçÁº©ÊîæÊØî‰æã
let originX = 0;          // ÂΩìÂâçÂπ≥ÁßªÂÅèÁßªX
let originY = 0;          // ÂΩìÂâçÂπ≥ÁßªÂÅèÁßªY
const scaleStep = 0.1;    // ÊØèÊ¨°ÊªöËΩÆÁº©ÊîæÊ≠•Èïø
const minScale = 0.5;     // ÊúÄÂ∞èÁº©ÊîæÂÄçÊï∞
const maxScale = 3;       // ÊúÄÂ§ßÁº©ÊîæÂÄçÊï∞

// ÁΩëÊ†ºÂèÇÊï∞
const gridSize = 50;           // ÊØè‰∏™Ê†ºÂ≠êÁöÑÂÆΩÈ´òÔºàÂÉèÁ¥†Ôºâ
const gridColor = '#ddd';        // ÁΩëÊ†ºÁ∫øÈ¢úËâ≤
const lineWidth = 1;          // ÁΩëÊ†ºÁ∫øÂÆΩÂ∫¶

// 3x3 ÊñπÊ°ÜÂèÇÊï∞
const boxGridWidth = 3;
const boxGridHeight = 3;
const boxBackgroundColor = '#e3f2fd';  // ÊµÖËìùËâ≤ËÉåÊôØÔºàÂèØËá™ÂÆö‰πâÔºåÂ¶Ç '#f0f0f0'„ÄÅ'#cce7ff' Á≠âÔºâ
const boxText = 'üêª';                 // ‰Ω†ÊÉ≥Ë¶ÅÊòæÁ§∫ÁöÑÊñáÂ≠óÔºåÊØîÂ¶Ç "A1", "Â∫ß‰Ωç1", "ü™ë"
const boxTextColor = '#000';           // ÊñáÂ≠óÈ¢úËâ≤
const boxTextSize = 64;                 // ÊñáÂ≠óÂ≠óÂè∑ÔºàÂÉèÁ¥†Ôºâ

// ‰Ωú‰∏∫Êï∞ÊçÆ
const seatCanvas = ref(null);

// Áé©ÂÆ∂Êï∞ÊçÆ
const count = ref(0);
const fileList = ref([]);
const percentage = ref(0);
const showModal = ref(false);
const height = ref(window.innerHeight * 0.7);
const tableData = ref([]);

function handleSorterChange(sorter) {
  if (sorter.order === false) {
    seatDatum = [...tableData.value];
  } else {
    seatDatum = [...tableData.value].sort((a, b) => {
      const valA = Number(a[sorter.columnKey]);
      const valB = Number(b[sorter.columnKey]);

      if (isNaN(valA)) return 1;
      if (isNaN(valB)) return -1;

      return sorter.order === 'descend' ? valB - valA : valA - valB;
    });
  }
};

const getDataIndex = (key) => {
  return tableData.value.findIndex((item) => item.key === key);
};

const ShowOrEdit = defineComponent({
  props: {
    value: [String, Number],
    onUpdateValue: [Function, Array]
  },
  setup(props) {
    const isEdit = ref(false);
    const inputRef = ref(null);
    const inputValue = ref(props.value);
    function handleOnClick() {
      isEdit.value = true;
      nextTick(() => {
        inputRef.value?.focus();
      });
    }
    function handleChange() {
      props.onUpdateValue?.(String(inputValue.value));
      isEdit.value = false;
    }
    return () => h(
      "div",
      {
        style: "min-height: 22px",
        onClick: handleOnClick
      },
      isEdit.value ? h(NInput, {
        ref: inputRef,
        value: String(inputValue.value),
        onUpdateValue: (v) => {
          inputValue.value = v;
        },
        onChange: handleChange,
        onBlur: handleChange
      }) : props.value
    );
  }
});

const parsePlayerData = (result) => {
  const playerData = {};

  const lines = result.text.split(/\r?\n/);
  for (const item of lines) {
    if (!playerData['name'] && (item.includes('qgd') || item.includes('qgD') || item.includes('qGd') || item.includes('qGD') || item.includes('Qgd') || item.includes('QgD') || item.includes('QGd') || item.includes('QGD'))) {
      let cleaned = item.replace(/^.*?„ÄêQGD„Äë/i, '');
      cleaned = cleaned.replace(/^.*?\[QGD\]/i, '');
      cleaned = cleaned.split(' ').filter(item => item.trim() !== '');
      playerData['name'] = cleaned[0];
    }

    if (item.includes('ÁõæÂÖµÊîªÂáª')) {
      const cleaned = item.split(' ').filter(item => item.trim() !== '')
      playerData['dbgjl'] = Math.trunc(Number(cleaned[1].replace("%", "").replace("+", "")) * 10) / 10
    }
    if (item.includes('ÁõæÂÖµÈò≤Âæ°')) {
      const cleaned = item.split(' ').filter(item => item.trim() !== '')
      playerData['dbfyl'] = Math.trunc(Number(cleaned[1].replace("%", "").replace("+", "")) * 10) / 10
    }
    if (item.includes('ÁõæÂÖµÁ©øÈÄè')) {
      const cleaned = item.split(' ').filter(item => item.trim() !== '')
      playerData['dbctl'] = Math.trunc(Number(cleaned[1].replace("%", "").replace("+", "")) * 10) / 10
    }
    if (item.includes('ÁõæÂÖµÁîüÂëΩ')) {
      const cleaned = item.split(' ').filter(item => item.trim() !== '')
      playerData['dbsml'] = Math.trunc(Number(cleaned[1].replace("%", "").replace("+", "")) * 10) / 10
    }

    if (item.includes('ÁüõÂÖµÊîªÂáª')) {
      const cleaned = item.split(' ').filter(item => item.trim() !== '')
      playerData['mbgjl'] = Math.trunc(Number(cleaned[1].replace("%", "").replace("+", "")) * 10) / 10
    }
    if (item.includes('ÁüõÂÖµÈò≤Âæ°')) {
      const cleaned = item.split(' ').filter(item => item.trim() !== '')
      playerData['mbfyl'] = Math.trunc(Number(cleaned[1].replace("%", "").replace("+", "")) * 10) / 10
    }
    if (item.includes('ÁüõÂÖµÁ©øÈÄè')) {
      const cleaned = item.split(' ').filter(item => item.trim() !== '')
      playerData['mbctl'] = Math.trunc(Number(cleaned[1].replace("%", "").replace("+", "")) * 10) / 10
    }
    if (item.includes('ÁüõÂÖµÁîüÂëΩ')) {
      const cleaned = item.split(' ').filter(item => item.trim() !== '')
      playerData['mbsml'] = Math.trunc(Number(cleaned[1].replace("%", "").replace("+", "")) * 10) / 10
    }

    if (item.includes('Â∞ÑÊâãÊîªÂáª')) {
      const cleaned = item.split(' ').filter(item => item.trim() !== '')
      playerData['ssgjl'] = Math.trunc(Number(cleaned[1].replace("%", "").replace("+", "")) * 10) / 10
    }
    if (item.includes('Â∞ÑÊâãÈò≤Âæ°')) {
      const cleaned = item.split(' ').filter(item => item.trim() !== '')
      playerData['ssfyl'] = Math.trunc(Number(cleaned[1].replace("%", "").replace("+", "")) * 10) / 10
    }
    if (item.includes('Â∞ÑÊâãÁ©øÈÄè')) {
      const cleaned = item.split(' ').filter(item => item.trim() !== '')
      playerData['ssctl'] = Math.trunc(Number(cleaned[1].replace("%", "").replace("+", "")) * 10) / 10
    }
    if (item.includes('Â∞ÑÊâãÁîüÂëΩ')) {
      const cleaned = item.split(' ').filter(item => item.trim() !== '')
      playerData['sssml'] = Math.trunc(Number(cleaned[1].replace("%", "").replace("+", "")) * 10) / 10
    }
  }

  console.log(playerData);
  return playerData;
}

const handleUploadChange = async (fielInfo) => {
  console.log(fielInfo)

  showModal.value = true;
  const imgFile = fielInfo.file.file;

  const img = new Image()
  img.src = URL.createObjectURL(imgFile)

  img.onload = async () => {
    // ÂàõÂª∫Á¶ªÂ±è Canvas
    const offCanvas = document.createElement('canvas');
    const ctx = offCanvas.getContext('2d');
    offCanvas.width = img.width;
    offCanvas.height = img.height;
    ctx.drawImage(img, 0, 0);

    // ÁÅ∞Â∫¶ÂåñÂ§ÑÁêÜ
    const imageData = ctx.getImageData(0, 0, img.width, img.height);
    const data = imageData.data;
    for (let i = 0; i < data.length; i += 4) {
      const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
      data[i] = data[i + 1] = data[i + 2] = gray;
    }
    ctx.putImageData(imageData, 0, 0);

    // OCR ËØÜÂà´ÁÅ∞Â∫¶Âõæ
    const worker = await createWorker({
      workerPath: window.location.origin + import.meta.env.BASE_URL + '/tesseract/worker.min.js',
      langPath: window.location.origin + import.meta.env.BASE_URL + '/lang-data',
      gzip: false,
    });
    await worker.loadLanguage('chi_sim_fast');
    await worker.initialize('chi_sim_fast');
    const { data: result } = await worker.recognize(offCanvas)

    const playerData = parsePlayerData(result);
    tableData.value.push(playerData);

    count.value++;
    percentage.value = (count.value / fileList.value.length) * 100;
  }
}

const drawSeat = () => {
  const canvas = seatCanvas.value
  if (!canvas) return

  const ctx = canvas.getContext('2d')
  if (!ctx) return

  ctx.clearRect(0, 0, canvas.width, canvas.height)

  // ============================
  // ÁªòÂà∂ÁΩëÊ†º
  // ============================
  ctx.strokeStyle = gridColor
  ctx.lineWidth = lineWidth

  // ÁªòÂà∂ÂûÇÁõ¥Á∫ø
  for (let x = 0; x <= canvas.width; x += gridSize) {
    ctx.beginPath()
    ctx.moveTo(x, 0)
    ctx.lineTo(x, canvas.height)
    ctx.stroke()
  }

  // ÁªòÂà∂Ê∞¥Âπ≥Á∫ø
  for (let y = 0; y <= canvas.height; y += gridSize) {
    ctx.beginPath()
    ctx.moveTo(0, y)
    ctx.lineTo(canvas.width, y)
    ctx.stroke()
  }

  // ============================
  // ÁªòÂà∂ 3x3 ÁöÑÊñπÊ°ÜÔºàÁ≤æÂáÜÂØπÈΩêÁΩëÊ†ºÔºâ
  // ============================
  const boxWidth = boxGridWidth * gridSize     // 3 * 40 = 120
  const boxHeight = boxGridHeight * gridSize   // 3 * 40 = 120

  // ÁîªÂ∏É‰∏≠ÂøÉÁÇπÂùêÊ†á
  const canvasCenterX = canvas.width / 2
  const canvasCenterY = canvas.height / 2

  const gridStepX = gridSize
  const gridStepY = gridSize

  const desiredCenterX = canvasCenterX
  const desiredCenterY = canvasCenterY

  const desiredLeft = desiredCenterX - boxWidth / 2
  const desiredTop = desiredCenterY - boxHeight / 2

  const alignedLeft = Math.round(desiredLeft / gridStepX) * gridStepX
  const alignedTop = Math.round(desiredTop / gridStepY) * gridStepY

  const boxLeft = alignedLeft
  const boxTop = alignedTop

  // 1. Â°´ÂÖÖÊñπÊ°ÜËÉåÊôØËâ≤
  ctx.fillStyle = boxBackgroundColor
  ctx.fillRect(boxLeft, boxTop, boxWidth, boxHeight)

  // 2. Âú®ÊñπÊ°ÜÂÜÖÈÉ®Â±Ö‰∏≠ÁªòÂà∂ÊñáÂ≠ó
  ctx.fillStyle = boxTextColor
  ctx.font = `${boxTextSize}px Arial` // Â≠ó‰ΩìÂ§ßÂ∞è‰∏éÁ±ªÂûã
  ctx.textAlign = 'center'           // Ê∞¥Âπ≥Â±Ö‰∏≠
  ctx.textBaseline = 'middle'        // ÂûÇÁõ¥Â±Ö‰∏≠
  const textX = boxLeft + boxWidth / 2
  const textY = boxTop + boxHeight / 2

  ctx.fillText(boxText, textX, textY + 5)

  // ============================
  // ÁªòÂà∂ 1x1 ÁöÑÊñπÊ°ÜÔºàÁ≤æÂáÜÂØπÈΩêÁΩëÊ†ºÔºâ
  // ============================
  const startGridX = Math.floor(boxLeft / gridSize)
  const startGridY = Math.floor(boxTop / gridSize)

  const smallBoxes = [
    { x: startGridX - 1, y: startGridY - 1 }, // Â∑¶‰∏ä
    { x: startGridX + 3, y: startGridY - 1 }, // Âè≥‰∏ä
    { x: startGridX - 1, y: startGridY + 3 }, // Â∑¶‰∏ã
    { x: startGridX + 3, y: startGridY + 3 }, // Âè≥‰∏ã
  ]

  smallBoxes.forEach(({ x, y }) => {
    const pixelX = x * gridSize
    const pixelY = y * gridSize

    // ËÉåÊôØ
    ctx.fillStyle = "#66bb6a"
    ctx.fillRect(pixelX, pixelY, gridSize, gridSize)

    const text = 'üö©'
    ctx.font = '32px Arial' // Â≠óÂè∑ÂíåÂ≠ó‰ΩìÔºàÂèØË∞ÉÊï¥ÔºåÂ¶Ç '14px sans-serif'Ôºâ
    ctx.textAlign = 'center' // Ê∞¥Âπ≥Â±Ö‰∏≠
    ctx.textBaseline = 'middle' // ÂûÇÁõ¥Â±Ö‰∏≠
    const textX = pixelX + gridSize / 2
    const textY = pixelY + gridSize / 2

    ctx.fillText(text, textX, textY)
  })

  // ============================
  // ÁªòÂà∂ 2x2 ÁöÑÊñπÊ°Ü
  // ============================
  // ÂåóÁéØ
  const oneRingNorthSeat = [-1, 1, 3, 5, 7, 9];
  for (let i = 0; i < 3; i++) {
    for (let j = 0; j < oneRingNorthSeat.length; j++) {
      const value = oneRingNorthSeat[j]
      let seatX = (startGridX + value) * gridSize;
      let seatY = (startGridY - (3 + (i * 2))) * gridSize;

      ctx.fillStyle = "#fff"
      ctx.fillRect(seatX, seatY, gridSize * 2, gridSize * 2)

      ctx.strokeStyle = "#000"
      ctx.lineWidth = 1
      ctx.strokeRect(seatX, seatY, gridSize * 2, gridSize * 2)

      const keys = seatKey.get('north');
      let label = keys.get(i + "")[j];

      if (seatDatum.length >= label) {
        label = seatDatum[label - 1].name
      }

      ctx.font = '14px Arial'
      ctx.textAlign = 'center'
      ctx.textBaseline = 'middle'
      ctx.fillStyle = 'black'
      let labelX = seatX + gridSize
      let labelY = seatY + gridSize
      ctx.fillText(label, labelX, labelY)
    }
  }

  // ‰∏úÁéØ
  const oneRingEastSeat = [-1, 1, 3, 5, 7, 9];
  for (let i = 0; i < 3; i++) {
    for (let j = 0; j < oneRingEastSeat.length; j++) {
      const value = oneRingEastSeat[j]
      let seatX = (startGridX + (4 + (i * 2))) * gridSize;
      let seatY = (startGridY + value) * gridSize;

      ctx.fillStyle = "#fff"
      ctx.fillRect(seatX, seatY, gridSize * 2, gridSize * 2)

      ctx.strokeStyle = "#000"
      ctx.lineWidth = 1
      ctx.strokeRect(seatX, seatY, gridSize * 2, gridSize * 2)

      const keys = seatKey.get('east');
      let label = keys.get(i + "")[j];

      if (seatDatum.length >= label) {
        label = seatDatum[label - 1].name
      }

      ctx.font = '14px Arial'
      ctx.textAlign = 'center'
      ctx.textBaseline = 'middle'
      ctx.fillStyle = 'black'
      let labelX = seatX + gridSize
      let labelY = seatY + gridSize
      ctx.fillText(label, labelX, labelY)
    }
  }

  // ÂçóÁéØ
  const oneRingSouthSeat = [2, 0, -2, -4, -6, -8];
  for (let i = 0; i < 3; i++) {
    for (let j = 0; j < oneRingSouthSeat.length; j++) {
      const value = oneRingSouthSeat[j]
      let seatX = (startGridX + value) * gridSize;
      let seatY = (startGridY + (4 + (i * 2))) * gridSize;

      ctx.fillStyle = "#fff"
      ctx.fillRect(seatX, seatY, gridSize * 2, gridSize * 2)

      ctx.strokeStyle = "#000"
      ctx.lineWidth = 1
      ctx.strokeRect(seatX, seatY, gridSize * 2, gridSize * 2)

      const keys = seatKey.get('south');
      let label = keys.get(i + "")[j];

      if (seatDatum.length >= label) {
        label = seatDatum[label - 1].name
      }

      ctx.font = '14px Arial'
      ctx.textAlign = 'center'
      ctx.textBaseline = 'middle'
      ctx.fillStyle = 'black'
      let labelX = seatX + gridSize
      let labelY = seatY + gridSize
      ctx.fillText(label, labelX, labelY)
    }
  }

  // Ë•øÁéØ
  const oneRingWestSeat = [2, 0, -2, -4, -6, -8];
  for (let i = 0; i < 3; i++) {
    for (let j = 0; j < oneRingWestSeat.length; j++) {
      const value = oneRingWestSeat[j]
      let seatX = (startGridX - (3 + (i * 2))) * gridSize;
      let seatY = (startGridY + value) * gridSize;

      ctx.fillStyle = "#fff"
      ctx.fillRect(seatX, seatY, gridSize * 2, gridSize * 2)

      ctx.strokeStyle = "#000"
      ctx.lineWidth = 1
      ctx.strokeRect(seatX, seatY, gridSize * 2, gridSize * 2)

      const keys = seatKey.get('west');
      let label = keys.get(i + "")[j];

      if (seatDatum.length >= label) {
        label = seatDatum[label - 1].name
      }

      ctx.font = '14px Arial'
      ctx.textAlign = 'center'
      ctx.textBaseline = 'middle'
      ctx.fillStyle = 'black'
      let labelX = seatX + gridSize
      let labelY = seatY + gridSize
      ctx.fillText(label, labelX, labelY)
    }
  }
}

// Âú®ÁªÑ‰ª∂ÊåÇËΩΩÂêéÁªòÂà∂
onMounted(async () => {
  drawSeat();

  seatCanvas.value.addEventListener('wheel', (event) => {
    event.preventDefault();

    const canvas = seatCanvas.value
    if (!canvas) return

    const ctx = canvas.getContext('2d')
    if (!ctx) return

    // ËÆ°ÁÆóÈº†Ê†áÁõ∏ÂØπ canvas ÁöÑÂùêÊ†á
    const rect = canvas.getBoundingClientRect();
    const mouseX = event.clientX - rect.left;
    const mouseY = event.clientY - rect.top;

    // ÊªöËΩÆÊñπÂêë
    const delta = event.deltaY < 0 ? 1 : -1;

    // Êñ∞ÁöÑÁº©ÊîæÊØî‰æã
    const newScale = Math.min(Math.max(scale + delta * scaleStep, minScale), maxScale);

    // ‰øùÊåÅÈº†Ê†á‰ΩçÁΩÆÂú®Áº©ÊîæÂêé‰ªçÊåáÂêëÁõ∏ÂêåÂÜÖÂÆπ
    originX = mouseX - ((mouseX - originX) * (newScale / scale));
    originY = mouseY - ((mouseY - originY) * (newScale / scale));

    scale = newScale;

    // Ê∏ÖÁ©∫ÁîªÂ∏É
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Â∫îÁî®Áº©ÊîæÂíåÂπ≥Áßª
    ctx.save();
    ctx.setTransform(scale, 0, 0, scale, originX, originY);

    drawSeat(); // ÈáçÊñ∞ÁªòÂà∂

    ctx.restore();
  })
});

onUnmounted(async () => { });
</script>

<style scoped>
.main {
  height: calc(100vh - 125px);
  display: flex;
}

.left {
  width: 80%;
  height: 100%;
}

.right {
  width: 20%;
  height: 100%;
  display: flex;
}
</style>